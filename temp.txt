Lesson 25: Repetition in Regex Patterns and Greedy/Nongreedy Matching (p154 - 157)

Key Words:
1.
2. ? (zero or one)
3. * (Zero or more)
4. + (one or more)
5. Escaping ?, *, and +
6. {x} (exactly x)


1.

	The Pipe Character that we've went over in the last lesson lets you match one of many possible groups in a Regular Expression. But you may want to also match a certain number of repetitions of the group. You may want to match at least one or more appearances of the group, or you may want to match the group if it appear more than 7 times but less than 10 times. 

	In this lesson, you'll learn the regular expression syntax for matching a specific number of repetitions. 

	So to start of with, I'm just going to import the "re" regular expressions module. 

		>>> import re

2. (0:42)
? (zero or one)
	
	And lets begin with the first character, the "?" character. This says, match the preceding group zero or one times. It's an optional group. It can either appear once or not appear at all. 

	So let's use some code. I'm going to use a "batman" Regular Expression, that i'll save in this "batRegex" variable. So i'll call re.compile() so that it will return a Regular Expression Object. And the pattern that i want this to match will either be batman or batwoman.

		>>> batRegex = re.compile(r'Batman|Batwoman')

	But in this case, I could make this a bit shorter by just saying, adding (wo) group, and then a ? after it. 

		>>> batRegex = re.compile(r'Bat(wo)?man')

	So this ? says, this group right here can appear in the text zero or one times in order to match this pattern. So if we call this Regular Expression Object's .search() Method, and searched a string like, "The Adventures of Batman". We can see that this Regular Expression does indeed match this string. It found this pattern, Bat(wo)?man, in this string,  "The Adventures of Batman".

		>>> batRegex = re.compile(r'Bat(wo)?man')
		>>> mo = batRegex.search('The Adventures of Batman')
		>>> mo.group()
		'Batman'

	And we can see that it match "Batman", but this will also match "The Adventures of Batwoman"

		>>> batRegex = re.compile(r'Bat(wo)?man')
		>>> mo = batRegex.search('The Adventures of Batwoman')
		>>> mo.group()
		'Batwoman'

	Because the (wo) group, here, can appear one or zero times. It appears zero times here: ('The Adventures of Batman'), and it appears once here: ('The Adventures of Batwoman')

	But if we add something like, "The Adventures of Batwowowowowoman", that actually does not match the pattern at all.

		>>> batRegex = re.compile(r'Bat(wo)?man')
		>>> mo = batRegex.search('The Adventures of Batwowowowowoman')
		>>> mo == None
		True

	Because it can only appear zero or one times. So the .search() Method will return "None" to the "mo" variable.  

	Using the earlier Phone Number example, we can make a regular expression that looks for phone numbers that do or do not have an area code, that is we can make the area code optional. 

	So let's enter this into the interactive shell. I'm going to create a Regular Expression object by calling re.compile and store it in "phoneRegex".

		>>> phoneRegex = re.compile()

	And the pattern for phone numbers we can us that slash d, which stands for "Any Numeric Digit". So we can have 3 digits for the area code, 3 digits for the first part of the phone number, and then the last 4 digits of the phone number.

		>>> phoneReex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')

	So this is the phone number Regex that requires a phone number to have an area code. So if i had a string, "My phone number is 415-555-1234. Call me tomorrow." We'll just save that into the variable "mo" because it'll return a matched object. 

		>>> phoneReex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
		>>> mo = phoneRegex.search('My phone number is 415-555-1234. Call me tomorrow.')
		>>> mo.group()
		'415-555-1234'

	We can see that this actually found the phone number with the area code, except this pattern requires the area code, won't be able to match anything the string doesn't have the area code. 

		>>> phoneReex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
		>>> mo = phoneRegex.search('My phone number is 555-1234. Call me tomorrow.')
		>>> mo == None
		True 

	So search returns None, to the mo variable will contain the None Value. 

	So instead, let's create a Regular Expression object, phoneRegex, that puts this area code into a group, and then we have the ? to say, this preceding group is optional.  It can either appear once, or appear zero times. 

		>>> phoneRegex = re.compile(r'(\d\d\d-)?\d\d\d-\d\d\d\d')

	And in this case, we can see that the .search() Method does return a Matched Object. for this phone number, 415-555-1234, and also returns a Matched Object for this phone number, 555-1234, when it doesn't have an area code in front of it. 

		>>> phoneRegex = re.compile(r'(\d\d\d-)?\d\d\d-\d\d\d\d')
		>>> phoneRegex.search('My phone number is 415-555-1234. Call me tomorrow.')
		<_sre.SRE_Match object; span=(19, 31), match='415-555-1234'>

		>>> phoneRegex = re.compile(r'(\d\d\d-)?\d\d\d-\d\d\d\d')
		>>> phoneRegex.search('My phone number is 555-1234. Call me tomorrow.')
		<_sre.SRE_Match object; span=(19, 31), match='555-1234'>

	And if you ever have to literally match a ?, as part of your pattern, you can escape the ? with a backslash in front of it. 

		\?

	For Example, if you wanted a regex object for the text "dinner?" (with the question mark), you would call: 

			>>> re.compile(r'dinner\?') # note the slash in \?

	In the above case, "dinner" is not optional, we are literally looking for a question mark: "dinner?"
	
3. (4:44)
* (Zero or more)

	The * character is usually called the star character in the context of Regular Expressions. And it means, match zero or more times. 

	So lets go back to that batman Regular Expression example.  Creating that Regular Expression, and before we added the ? here, which meant that this (wo) could appear one or zero times. 

		>>> batRegex = re.compile(r'Bat(wo)?man')

	If we change that to a star, this means this can appear zero or more times. So basically any number of times. 

		>>> batRegex = re.compile(r'Bat(wo)*man')

	This will actually match "The Adventures of Batman" string, it will also match "The Adventures of Batwoman" string, and since it can accept any number of this (wo) group because the star means zero or more, we can have several of that and it will still match that string.

		>>> batRegex = re.compile(r'Bat(wo)*man')
		>>> batRegex.search('The Adventures of Batman')
		<_sre.SRE_Match object; span=(18, 24), match='Batman'>
		>>> batRegex.search('The Adventures of Batwoman')
		<_sre.SRE_Match object; span=(18, 26), match='Batwoman'>
		>>> batRegex.search('The Adventures of Batwowowowoman')
		<_sre.SRE_Match object; span=(18, 38), match='Batwowowowoman'>

	And if you need to a literal * that appears as part of the pattern, you can escape it with a backslash. 

		\*

4 (5:56)
+ (one or more)

	While the * means "Matches zero or more", the + character means "Match one or more".  So unlike the star that doesn't require it's group in the match string, the group preceding the + must appear at least once. It's not optional. 

	So let's create another Batman Regular Expression object by calling re.compile(), and let's say that that (wo) group is now required to appear one or more times. 

		>>> batRegex = re.compile(r'Bat(wo)+man')

	This means that matching "The Adventures of Batman" string, it won't actually find that. This function call will return "None"

		>>> batRegex = re.compile(r'Bat(wo)+man')
		>>> batRegex.search('The Adventures of Batman')
		>>> batRegex.search('The Adventures of Batman') == None
		True

	However, "The Adventures of Batwoman" will match it, because this (wo) group appears once. And then also this example with "The Adventures of Batwowowowoman", that will also match, because that (wo) group can appear one or more times. 

		>>> batRegex.search('The Adventures of Batwoman')
		<_sre.SRE_Match object; span=(18, 26), match='Batwoman'>
		>>> batRegex.search('The Adventures of Batwowowowoman')
		<_sre.SRE_Match object; span=(18, 38), match='Batwowowowoman'>

	And if you have to match a literal + that appears in your pattern, you can escape it with a backslash. 

		\+

5. (7:11)
Escaping ?, *, and +

	So let's have a quick example with that Escaping. Let's say that I'm going to create a Regex object by call re.compile() and the pattern that i'm looking for is a literal "+" followed by a literal "*" followed by a literal "?". 

		>>> regex = re.compile(r'\+\*\?')

	That would match a string that looks something like "I learned about +*? regex syntax". 

		>>> regex = re.compile(r'\+\*\?')
		>>> regex.search('I learned about +*? regex syntax')
		<_sre.SRE_Match object; span=(16, 19),  match='+*?'>

	And this will actually match these characters "+ * ?". So if you literally want to match these characters that otherwise have a special meaning for regular expressions strings, you can just precede them with a backslash to Escape them. 

	In fact, we can even have something like putting this inside a group, and saying this has to appear one or more times, by have a + that means, oh, one or more times. And that would match a string that looks like this: "I learned about +*?+*?+*?+*?+*? regex syntax"

		>>> regex = re.compile(r'(\+\*\?)+')
		>>> regex.search('I learned about +*?+*?+*?+*?+*? regex syntax')
		<_sre.SRE_Match object; span=(16, 31),  match='+*?+*?+*?+*?+*?'>

	So here it means, literally i want you to find a + that appears in the string that I am looking for, that's part of the text pattern and the second + is more of a Regular Expression instruction that's saying, "Match one or more of this preceding groups in the parenthesis" 
		
recap 

 ?: zero or one
 *: zero or more
 +: one or more 
	
6. (8:58)
{x} (exactly x)

	Let's say you wanted to match a specific number of repetitions of a group. We can do that in python. I'm going to create a Regular Expression object that matches the string "Ha" exactly 3 times, and we can to that with "{}" with the number "3" in-between them. 

		>>> haRegex = re.compile(r'(Ha) {3}')

	So if we call the .search() Method here, we can search for 'He said "HaHaHa"'. 

		>>> haRegex = re.compile(r'(Ha) {3}')
		>>> haRegex.search('He said "HaHaHa"')
		<_sre.SRE_Match object; span=(9, 15), match='HaHaHa'>

	We can see that this string, 'HaHaHa', is matched in the regular expression.

	This is kind of a simple example that you might think, couldn't we just have something like: 

		>>> haRegex = re.compile(r'HaHAhA')

	And this would work too this would do the exact same thing as this, (r'(Ha) {3}'), but the nice part about this syntax is that you can have something like, say, if we wanted to match multiple phone numbers that either have or did not have the area code in front. So that expression would look like this:

		>>> phoneRegex = re.compile(r'(\d\d\d-)?\d\d\d-\d\d\d\d')

	Where we have the optional area code, these are 3 digits and a dash which can appear zero or one times, (\d\d\d-)?, and then we have the rest of the 7 digits of the phone number. 

	And now we can put all of that inside a group and just say, we want to match 3 phone numbers in a row.   

		>>> phoneRegex = re.compile(r'((\d\d\d-)?\d\d\d-\d\d\d\d){3}')

	That might look a little bit strange, so let's say they also have a "," that they are separated by except that "," is also optional. (10:49)
	
RECAP:
-
